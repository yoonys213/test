<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>불확도 계산기</title>
  <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://webfontworld.github.io/gmarket/GmarketSans.css" rel="stylesheet">
  <!-- Tailwind CSS (CDN 버전 예시) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&display=swap');
    
    .parentheses {
    font-size: clamp(1.5rem, 5vw, 2.5rem); /* 화면 너비에 따라 크기 조절 */
    font-weight: bold;
    color: #030BA6;
    }
    input::placeholder {
      color: #9CA3AF;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 10;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.4);
    }
    .modal-content {
      background-color: white;
      margin: 10% auto;
      padding: 2rem;
      border-radius: 1rem;
      width: 80%;
      max-width: 600px;
      position: relative;
    }
    .box-header {
      background-color: #2E6FF2;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem 0.5rem 0 0;
      font-weight: bold;
      margin: -0.5rem -0.5rem 0.5rem -0.5rem;
    }
    /* 탭 스타일 재정의 */
    .box-tab {
    position: absolute;
    top: 0;
    left: 0;
    background-color: white;
    color: #030BA6;
    padding: 0.25rem 1rem;
    font-weight: bold;
    border-top-left-radius: 0.5rem;
    border-top-right-radius: 0.5rem;
    transform: translateY(-50%);
    z-index: 1;
    }
    body {
      font-family: 'Noto Sans KR', sans-serif;
    }
    .title-font {
    font-family: 'GmarketSans', sans-serif;
    font-weight: 500; /* 300, 500, 700 가능 */
    }
    .back-btn {
    position: absolute;
    left: 3vw;
    top: 50%;
    transform: translateY(-50%);
    color: white;
    font-size: clamp(40px, 8vw, 60px);
    font-weight: 900;
    cursor: pointer;
    background: transparent;
    width: clamp(50px, 10vw, 80px);
    height: clamp(50px, 10vw, 80px);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s;
    z-index: 10;
    border: none;
    outline: none;
    text-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    .back-btn::before {
    content: "〈";
    display: block;
    line-height: 1;
    }
    .back-btn:hover {
        transform: translateY(-50%) scale(1.2);
        text-shadow: 0 0 15px rgba(0,0,0,0.8);
      }
    @media (max-width: 768px) {
    .back-btn {
      left: 2vw;
    }
    }
  </style>
</head>
<body class="bg-[#729DF2] flex items-center justify-center h-screen">
  <!-- 뒤로 가기 버튼 (중앙 정렬) -->
  <button onclick="try{location.href='calculsel.html';}catch(e){alert('이전 페이지로 이동할 수 없습니다.');}" 
      class="back-btn"></button>

      
  </button>

      <h1 class="absolute top-[0.5rem] left-40 text-white text-6xl font-bold title-font tracking-wide">
    불확도 계산기
    </h1>

  <!-- 메인 컨테이너 -->
  <div class="w-4/5 h-[75%] flex rounded-2xl overflow-auto shadow-2xl">
    <!-- 왼쪽 영역 - 계산 과정 및 결과 박스 (박스 위에 작은 박스 느낌) -->
    <div class="w-1/2 flex flex-col justify-between p-6">
      <!-- 계산 과정 박스 -->
      <div class="bg-white rounded-xl p-4 h-[70%] flex flex-col relative shadow-md">
        <div class="box-tab">계산 과정</div>
        <div id="calculation-process" class="flex-grow overflow-y-auto text-[#030BA6] font-semibold p-2 pt-6 whitespace-pre-wrap"></div>
      </div>
      
      <!-- 결과 박스 -->
        <div class="bg-white rounded-xl p-4 h-[26%] flex flex-col relative shadow-md">
        <div class="box-tab">결과</div>
        <div id="result" class="flex-grow overflow-y-auto text-[#030BA6] font-semibold text-2xl p-2 pt-6"></div>
        </div>
    </div>

    <!-- 오른쪽 영역 - 계산기 -->
    <div class="w-1/2 flex flex-col items-center p-6">
      <!-- 정보 버튼 -->
      <button id="infoBtn" class="self-end bg-[#2E6FF2] text-white rounded-full w-10 h-10 flex items-center justify-center font-bold mb-4 hover:bg-[#1a5bd9] transition">
        i
      </button>
      
      <!-- 입력 화면 -->
      <div class="bg-white rounded-2xl p-6 w-full mb-6 flex items-center justify-center">
        <div class="flex items-center text-[#030BA6]">
          <span class="parentheses">(</span>
          <input type="text" id="value" placeholder="값" oninput="validateNumber(this)" 
               class="w-24 text-center text-2xl font-semibold border-b-2 border-[#030BA6] focus:outline-none">
          <span class="parentheses">)</span>
          <span class="mx-2 text-2xl font-bold">±</span>
          <span class="parentheses">(</span>
          <input type="text" id="uncertainty" placeholder="불확도" oninput="validateNumber(this)" 
               class="w-24 text-center text-2xl font-semibold border-b-2 border-[#030BA6] focus:outline-none">
          <span class="parentheses">)</span>
        </div>
      </div>
      
      <!-- 버튼 그리드 -->
      <div class="bg-[#CEE1F2] rounded-2xl p-6 w-full flex flex-wrap justify-center gap-4 md:gap-8 lg:gap-12">
        <!-- 연산 버튼 -->
        <button onclick="appendOperation('+')" class="bg-[#2E6FF2] text-white rounded-full w-16 h-16 md:w-20 md:h-20 flex items-center justify-center text-2xl font-semibold hover:bg-[#1a5bd9] transition">
          +
        </button>
        <!-- 빼기 버튼 추가 -->
        <button onclick="appendOperation('−')" class="bg-[#2E6FF2] text-white rounded-full w-16 h-16 md:w-20 md:h-20 flex items-center justify-center text-2xl font-semibold hover:bg-[#1a5bd9] transition">
          −
        </button>
        <button onclick="appendOperation('×')" class="bg-[#2E6FF2] text-white rounded-full w-16 h-16 md:w-20 md:h-20 flex items-center justify-center text-2xl font-semibold hover:bg-[#1a5bd9] transition">
          ×
        </button>
        <button onclick="appendOperation('÷')" class="bg-[#2E6FF2] text-white rounded-full w-16 h-16 md:w-20 md:h-20 flex items-center justify-center text-2xl font-semibold hover:bg-[#1a5bd9] transition">
          ÷
        </button>
         <!-- 지우기 버튼 추가 -->
        <button onclick="backspace()" class="bg-[#2E6FF2] text-white rounded-full w-16 h-16 md:w-20 md:h-20 flex items-center justify-center text-2xl font-semibold hover:bg-[#1a5bd9] transition">
          ⌫
        </button>
        <button onclick="clearAll()" class="bg-[#2E6FF2] text-white rounded-full w-16 h-16 md:w-20 md:h-20 flex items-center justify-center text-xl font-semibold hover:bg-[#1a5bd9] transition">
          C
        </button>
        <!-- 불확도 바로 입력 버튼 -->
        <button onclick="setUncertainty(0.001)" class="bg-[#2E6FF2] text-white rounded-full w-16 h-16 md:w-20 md:h-20 flex items-center justify-center text-xl font-semibold hover:bg-[#1a5bd9] transition">
          0.001
        </button>
        
        <button onclick="calculate()" class="bg-[#2E6FF2] text-white rounded-full w-16 h-16 md:w-20 md:h-20 flex items-center justify-center text-2xl font-semibold hover:bg-[#1a5bd9] transition">
          =
        </button>
      </div>
    </div>
  </div>

  <!-- 정보 모달 (X 버튼 추가) -->
  <div id="infoModal" class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 hidden">
    <!-- 모달 내용 -->
    <div class="bg-white p-8 rounded-2xl max-h-[80vh] max-w-[90vw] overflow-y-auto overflow-x-hidden relative">
        <button id="closeModalBtn" class="absolute top-4 right-4 text-2xl font-bold text-[#030BA6] hover:text-[#2E6FF2]">
        ✕
        </button>
        <h2 class="text-[#030BA6] text-3xl font-bold mb-4">계산기 사용법</h2>
        <ul class="list-disc pl-5 space-y-2 text-[#030BA6]">
        <li>1. 키보드로 숫자를 입력하여 '값'과 '불확도' 칸을 채웁니다.</li>
        <li>2. 측정값 → 불확도 순으로 수를 입력하세요.</li>
        <li>3. 화면의 0.001 버튼으로 '불확도'를 빠르게 입력할 수 있습니다.</li>
        <li>4. 원하는 사칙연산 기호 버튼을 누르면 계산 과정에 추가됩니다.</li>
        <li>5. ⌫ (지우기) 버튼으로 마지막에 입력한 연산자나 숫자 그룹을 삭제할 수 있습니다.</li>
        <li>6. 식의 마지막에 등호(=) 버튼을 누르면 계산 결과가 Result 박스에 나타납니다.</li>
        <li>7. C 버튼을 눌러 식 전체를 초기화합니다.</li>
        <li>8. 이전 계산 결과가 있는 상태에서 바로 연산자 버튼을 누르면, 그 결과를 첫 값으로 사용해 계산을 이어갈 수 있습니다.</li>
        </ul>
    </div>
    </div>
    <script>
        
        let values = [];
        let uncertainties = [];
        let operations = [];
        let calculationHistory = "";
        let lastResult = null;

        // 입력값 유효성 검사 (3.0을 유지하기 위해 type="text" 사용)
        function validateNumber(input) {
            let value = input.value;
            // 소수점과 숫자만 허용
            value = value.replace(/[^0-9.]/g, '');
            // 중복 소수점 제거
            if ((value.match(/\./g) || []).length > 1) {
                value = value.substring(0, value.lastIndexOf('.'));
            }
            input.value = value;
        }

        // 소수점 자릿수 계산 (3.0은 1자리, 3은 0자리)
        function getDecimalPlaces(numStr) {
            if (!numStr || numStr === '') return 0;
            if (numStr.toString().indexOf('.') === -1) return 0;
            return numStr.toString().split('.')[1].length;
        }

        // 숫자 문자열을 숫자로 변환 (3.0 유지)
        function parseNumber(numStr) {
            if (numStr === '' || isNaN(numStr)) return NaN;
            return parseFloat(numStr);
        }

        // 엄격한 짝수 반올림
        function roundToEvenStrict(num, decimals) {
            if (isNaN(num)) return num;
            if (decimals === undefined || decimals < 0) decimals = 0;
            
            const factor = Math.pow(10, decimals);
            const absNum = Math.abs(num);
            const shifted = absNum * factor;
            const decimalPart = shifted - Math.floor(shifted);
            
            if (Math.abs(decimalPart - 0.5) > 1e-10) {
                return Math.round(shifted) / factor * Math.sign(num);
            }
            
            const integerPart = Math.floor(shifted);
            const lastDigit = integerPart % 10;
            
            if (lastDigit % 2 === 1) {
                return (integerPart + 1) / factor * Math.sign(num);
            } else {
                return integerPart / factor * Math.sign(num);
            }
        }

        // 불확도 반올림 (유효숫자 1개)
        function roundUncertainty(unc) {
            if (unc === 0) return 0;
            if (!isFinite(unc)) return "계산 불가";
            
            const magnitude = Math.floor(Math.log10(Math.abs(unc)));
            const factor = Math.pow(10, -magnitude);
            const rounded = Math.round(unc * factor) / factor;
            
            return parseFloat(rounded.toFixed(Math.max(0, -magnitude)));
        }

        function appendOperation(op) {
            let valueInput = document.getElementById("value").value;
            let uncertaintyInput = document.getElementById("uncertainty").value;

            if (valueInput === "" || uncertaintyInput === "") {
                if (lastResult && op) {
                    values = [lastResult.value.toString()];
                    uncertainties = [lastResult.uncertainty.toString()];
                    operations = [op];
                    calculationHistory = `(${lastResult.value} ± ${lastResult.uncertainty}) ${op} `;
                    document.getElementById("calculation-process").innerText = calculationHistory;
                    document.getElementById("result").innerText = "";
                    clearInputs();
                    lastResult = null; // lastResult 사용 후 초기화
                    return;
                }
                else if (op && values.length > 0 && operations.length === values.length -1) {
                    operations[operations.length - 1] = op;
                    calculationHistory = calculationHistory.trim().slice(0, -1).trim() + ` ${op} `;
                    document.getElementById("calculation-process").innerText = calculationHistory;
                }
                return;
            }

            const currentValue = valueInput; // 문자열로 저장
            const currentUncertainty = uncertaintyInput; // 문자열로 저장

            if (isNaN(parseFloat(currentValue)) || isNaN(parseFloat(currentUncertainty))) {
                alert("유효한 숫자를 입력해주세요.");
                return;
            }
            
            if (lastResult) {
                clearAll();
            }

            values.push(currentValue);
            uncertainties.push(currentUncertainty);
            operations.push(op);

            calculationHistory += `(${currentValue} ± ${currentUncertainty}) ${op} `;
            document.getElementById("calculation-process").innerText = calculationHistory;
            clearInputs();
            document.getElementById("value").focus();
        }

        // [새 기능] 지우기 함수
        function backspace() {
            if (lastResult) {
                clearAll();
                return;
            }
            // 마지막이 연산자인 경우
            if (values.length > 0 && values.length === operations.length) {
                operations.pop();
                calculationHistory = calculationHistory.trim().slice(0, -1).trim() + ' ';
            } 
            // 마지막이 숫자 그룹인 경우
            else if (values.length > 0) {
                values.pop();
                uncertainties.pop();
                let lastOpIndex = calculationHistory.trim().lastIndexOf(' ');
                calculationHistory = calculationHistory.substring(0, lastOpIndex).trim() + ' ';
                if(operations.length > 0) {
                   calculationHistory = calculationHistory.substring(0, calculationHistory.lastIndexOf(' ')).trim() + ' ';
                } else {
                   calculationHistory = "";
                }
            }
            
            document.getElementById("calculation-process").innerText = calculationHistory;
            document.getElementById("result").innerText = "";
            document.getElementById("value").focus();
        }

        function calculate() {
            let valueInput = document.getElementById("value").value;
            let uncertaintyInput = document.getElementById("uncertainty").value;

            // 마지막 입력 추가
            if (valueInput !== "" && uncertaintyInput !== "") {
                const val = valueInput;
                const unc = uncertaintyInput;
                if (isNaN(parseFloat(val)) || isNaN(parseFloat(unc))) {
                    alert("마지막으로 입력한 값이 유효한 숫자가 아닙니다.");
                    return;
                }
                values.push(val);
                uncertainties.push(unc);
                calculationHistory += `(${val} ± ${unc})`;
                document.getElementById("calculation-process").innerText = calculationHistory;
                clearInputs();
            } else if (values.length > 0 && values.length === operations.length) {
                alert("계산을 완료하려면 마지막 숫자를 입력하거나, 마지막 연산자를 제거하세요.");
                return;
            }
            
            if (values.length === 0) return;

            if (values.length === 1 && operations.length === 0) {
                lastResult = { 
                    value: parseNumber(values[0]), 
                    uncertainty: parseNumber(uncertainties[0]) 
                };
                document.getElementById("result").innerText = `(${lastResult.value} ± ${lastResult.uncertainty})`;
                // 계산 과정은 이미 있으므로 그대로 둠
                values = [];
                uncertainties = [];
                return;
            }


            if (values.length !== operations.length + 1) {
                alert("계산식의 숫자와 연산자 개수가 맞지 않습니다.");
                return;
            }

            let currentValStr = values[0];
            let currentUncStr = uncertainties[0];
            let currentVal = parseNumber(currentValStr);
            let currentUnc = parseNumber(currentUncStr);
            let calculationSteps = "";

            for (let i = 0; i < operations.length; i++) {
                let nextValStr = values[i + 1];
                let nextUncStr = uncertainties[i + 1];
                let nextVal = parseNumber(nextValStr);
                let nextUnc = parseNumber(nextUncStr);
                let op = operations[i];
                let resultValue, resultUncertainty;

                calculationSteps += `\n\n단계 ${i+1}: (${currentValStr} ± ${currentUncStr}) ${op} (${nextValStr} ± ${nextUncStr})`;

                // [수정 없음] 사용자가 제공한 원본 계산 로직
                if (op === '+' || op === '−') {
                    resultValue = (op === '+') ? currentVal + nextVal : currentVal - nextVal;

                    let relUnc1 = currentUnc / Math.abs(currentVal);
                    let relUnc2 = nextUnc / Math.abs(nextVal);
                    resultUncertainty = (relUnc1 + relUnc2) * Math.abs(resultValue);

                    const decPlaces1 = getDecimalPlaces(currentValStr);
                    const decPlaces2 = getDecimalPlaces(nextValStr);
                    const minDecimals = Math.min(decPlaces1, decPlaces2);

                    calculationSteps += `\n계산값: ${resultValue}`;
                    calculationSteps += `\n소수점 자릿수: ${currentValStr}(${decPlaces1}), ${nextValStr}(${decPlaces2}) → ${minDecimals}`;

                    resultValue = roundToEvenStrict(resultValue, minDecimals);

                    calculationSteps += `\n반올림 후 값: ${resultValue}`;
                    calculationSteps += `\n상대불확도 = (${currentUnc}/${Math.abs(currentVal)}) + (${nextUnc}/${Math.abs(nextVal)}) = ${relUnc1.toFixed(5)} + ${relUnc2.toFixed(5)} = ${(relUnc1 + relUnc2).toFixed(5)}`;
                    calculationSteps += `\n절대불확도 = ${(relUnc1 + relUnc2).toFixed(5)} × ${Math.abs(resultValue)} = ${resultUncertainty}`;
                } else if (op === '×' || op === '÷') {
                    if (op === '÷' && nextVal === 0) {
                        alert("0으로 나눌 수 없습니다.");
                        clearAll();
                        return;
                    }

                    resultValue = (op === '×') ? currentVal * nextVal : currentVal / nextVal;

                    let relUnc1 = currentUnc / Math.abs(currentVal);
                    let relUnc2 = nextUnc / Math.abs(nextVal);
                    resultUncertainty = (relUnc1 + relUnc2) * Math.abs(resultValue);

                    const sigFigs1 = getSignificantFigures(currentValStr);
                    const sigFigs2 = getSignificantFigures(nextValStr);
                    const minSigFigs = Math.min(sigFigs1, sigFigs2);
                    
                    calculationSteps += `\n값 = ${currentVal} ${op} ${nextVal} = ${resultValue}`;
                    resultValue = roundToSignificantFigures(resultValue, minSigFigs);
                    calculationSteps += `\n유효숫자: ${currentValStr}(${sigFigs1}), ${nextValStr}(${sigFigs2}) → ${minSigFigs}`;
                    calculationSteps += `\n반올림 후 값: ${resultValue}`;

                    calculationSteps += `\n상대불확도 = (${currentUnc}/${Math.abs(currentVal)}) + (${nextUnc}/${Math.abs(nextVal)}) = ${relUnc1.toFixed(5)} + ${relUnc2.toFixed(5)} = ${(relUnc1 + relUnc2).toFixed(5)}`;
                    calculationSteps += `\n절대불확도 = ${(relUnc1 + relUnc2).toFixed(5)} × ${Math.abs(resultValue)} = ${resultUncertainty}`;
                }

                currentVal = resultValue;
                currentUnc = resultUncertainty;
                currentValStr = resultValue.toString();
                currentUncStr = resultUncertainty.toString();
            }

            currentUnc = roundUncertainty(currentUnc);
            const uncertaintyDecimalPlaces = typeof currentUnc === 'number' ? getDecimalPlaces(currentUnc.toString()) : 0;
            currentVal = roundToEvenStrict(currentVal, uncertaintyDecimalPlaces);

            lastResult = {
                value: currentVal,
                uncertainty: currentUnc
            };

            document.getElementById("result").innerText = `(${currentVal} ± ${currentUnc})`;
            document.getElementById("calculation-process").innerText = calculationHistory + "\n" + calculationSteps;

            values = [];
            uncertainties = [];
            operations = [];
        }


        function getSignificantFigures(numStr) {
            if (!numStr) return 1;
            const str = numStr.toString();
            const num = parseFloat(str);
            if (num === 0) return 1;
            
            let sigFigs = 0;
            if(str.includes('.')){
                let nonZeroFound = false;
                for(let i = 0; i < str.length; i++){
                    if(str[i] === '.') continue;
                    if(str[i] !== '0') nonZeroFound = true;
                    if(nonZeroFound) sigFigs++;
                }
                return sigFigs;
            } else {
                return str.replace(/^0+/, '').length;
            }
        }

        function roundToSignificantFigures(num, sigFigs) {
            if (num === 0 || sigFigs < 1 || !isFinite(num)) return num;
            const magnitude = Math.floor(Math.log10(Math.abs(num)));
            const scale = Math.pow(10, sigFigs - magnitude - 1);
            return Math.round(num * scale) / scale;
        }

        function setUncertainty(value) {
            document.getElementById("uncertainty").value = value;
        }

        function clearInputs() {
            document.getElementById("value").value = "";
            document.getElementById("uncertainty").value = "";
        }

        function clearAll() {
            values = [];
            uncertainties = [];
            operations = [];
            calculationHistory = "";
            lastResult = null;
            document.getElementById("calculation-process").innerText = "";
            document.getElementById("result").innerText = "";
            clearInputs();
            document.getElementById("value").focus();
        }

        // 모달 및 이벤트 리스너
        document.addEventListener('DOMContentLoaded', () => {
            const modal = document.getElementById("infoModal");
            const btn = document.getElementById("infoBtn");
            const span = document.getElementById("closeModalBtn");

            if(btn) btn.onclick = function() {
                modal.style.display = "flex";
            }
            if(span) span.onclick = function() {
                modal.style.display = "none";
            }
            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                }
            }

            // 키보드 이벤트
            const valueInput = document.getElementById("value");
            const uncertaintyInput = document.getElementById("uncertainty");

            function handleKeyDown(event) {
                // [새 기능] 입력창이 비었을 때 Backspace 키를 누르면 backspace() 함수 실행
                if (event.key === "Backspace" && document.activeElement.value === "") {
                    event.preventDefault();
                    backspace();
                }
                if (event.key === "Enter") {
                    event.preventDefault();
                    calculate();
                } else if (event.key === "+") {
                    event.preventDefault();
                    appendOperation('+');
                } else if (event.key === "-") {
                    event.preventDefault();
                    appendOperation('−');
                } else if (event.key === "*") {
                    event.preventDefault();
                    appendOperation('×');
                } else if (event.key === "/") {
                    event.preventDefault();
                    appendOperation('÷');
                } else if (event.key === "Escape") {
                    event.preventDefault();
                    clearAll();
                }
                 else if (event.key === "Tab") {
                    event.preventDefault();
                    if (document.activeElement === valueInput) {
                        uncertaintyInput.focus();
                    } else {
                        valueInput.focus();
                    }
                }
            }

            if(valueInput) valueInput.addEventListener("keydown", handleKeyDown);
            if(uncertaintyInput) uncertaintyInput.addEventListener("keydown", handleKeyDown);
        });
    </script>
</body>
</html>
